global !p
TODO_TEMPLATE="TODO {0}."
TODO_PATTERN="TODO.*\."

class Argument(object):
	def __init__(self, argument_string):
		self._argument_string = argument_string

	@property
	def name(self):
		return self._argument_string.split('=')[0].strip()

	@property
	def is_kwarg(self):
		return len(self._argument_string.split('=')) > 1

	@property
	def default_value(self):
		return None if not self.is_kwarg else self._argument_string.split('=')[1].strip()


def shift_to_left_border():
	snip.buffer[snip.line] = ''; snip.cursor.set(snip.line, 0)

def on_jump(snippet, positions, function, arguments=None):
	if not isinstance(positions, list):
		positions = [positions]

	for position in positions:
		if position == "last":
			position = len(snippet.tabstops) - 1

		if position == snippet.tabstop:
			if arguments:
				function(arguments)
			else:
				function()

def secure_empty_line_wrap(arguments):
	snippet, count_before, count_after = arguments[0:3]
	force_count = arguments[3] if len(arguments) > 3 else False

	last_line = len(snippet.buffer) - 1

	snippet_start = snippet.snippet_start[0]
	snippet_end   = snippet.snippet_end[0] + 1

	index_before = snippet_start - count_before
	index_after = snippet_end + count_after

	if snippet_start > 0:
		for index in reversed(range(index_before, snippet_start)):
			if snippet.buffer[index]:
				missing_empty_lines = index - index_before + 1
				snippet.buffer.append([''] * missing_empty_lines, index + 1)
				snippet_end += missing_empty_lines
				index_after += missing_empty_lines
				last_line += missing_empty_lines
				added_lines_before = missing_empty_lines
				break

			elif index == index_before and force_count:
				while True:
					index -= 1
					if snippet.buffer[index]: break
					del snippet.buffer[index]
					snippet_end -= 1
					index_after -= 1
					last_line -= 1

	if snippet_end < last_line:
		for index in range(snippet_end, index_after):
			if snippet.buffer[index]:
				missing_empty_lines = index_after - index
				snippet.buffer.append([''] * missing_empty_lines, index)
				break

			elif index == index_after - 1 and force_count:
				index += 1

				while True:
					if snippet.buffer[index]: break
					del snippet.buffer[index]

def create_todo_snippet():
	import re
	content = snip.buffer[snip.snippet_start[0] : snip.snippet_end[0] + 1 ]
	snip.buffer[snip.snippet_start[0] : snip.snippet_end[0] + 1] = ''

	for index, line in enumerate(content):
		search_results = re.search(TODO_PATTERN, line)

		if search_results:
			rest = re.split(TODO_PATTERN, line)
			content[index] = f"{rest[0]} ${{{index + 1}:{search_results[0]}}}{rest[1]}"

	last_line_indent = " " * (len(content[-1]) - len(content[-1].strip()))
	content[-1] = f"{last_line_indent}${{0:{content[-1].strip()}}}"
	snippet = '\n'.join(content)
	snip.expand_anon(snippet)
endglobal

pre_expand "shift_to_left_border()"
snippet @pf "pytest fixture" bmA
@pytest.fixture(${1}`!p
if t[1] == 'p':
	t[1] = "params=[]"
`)
def ${2:fixture_name}(${3}):
	return ${0:None}
endsnippet


# post_expand "select_snippet()"
post_jump "on_jump(snip, 'last', secure_empty_line_wrap, [snip, 4, 2, True])"
snippet def "function" bmA
def ${1:function_name}($2):
`!p
snip.shift()
snip.rv += snip.mkline('""""' + TODO_TEMPLATE.format("function description"))

parameter = [ p.strip() for p in t[2].split(',') if bool(p and not p.isspace() and p != '*') ]

if parameter:
	snip.rv += '\n' * 2
	snip.rv += snip.mkline('Arguments:')
	snip.rv += '\n'

for p in parameter:
	parts = p.split('=')
	snip.rv += snip.mkline(
			f":param {parts[0]}: " +
			TODO_TEMPLATE.format(f"parameter description {' , optional' if len(parts) > 1 else ''}")
	)
	snip.rv += '\n'

snip.rv += snip.mkline('"""') if parameter else '"""'
`
	${3:pass}
endsnippet



post_jump "create_todo_snippet()"
snippet extend "extend documentation" bA
${VISUAL}
endsnippet


snippet class "class NAME: def __init__" b
class ${1:ClassName}:
	def __init__(self, ${2:constructor arguments...}):
		$0
endsnippet
